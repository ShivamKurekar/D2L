// Code for Master Dual Data Link (D2L)

module master (
    input clk, rstn,
    input out_en,
    output sclk, // slave clock generated by master to communicate
    output reg DL0, DL1,
    output reg CS
);

    
    reg [7:0]  data_in = 8'b0011_1010;

    reg [3:0] state, next_state;
    reg [2:0] count;

    reg slave_clk = 1'b0;
    reg [1:0] data_cycle;

    localparam IDLE = 0;
    localparam START_TX = 1;
    localparam DATA_TX = 2;
    localparam END_TX = 3;

    always @(posedge clk or negedge rstn) begin
        if (!rstn)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Slave clock generator

    always @(posedge clk or negedge rstn) begin

        if(!rstn) begin
            slave_clk <= 1'b0;
        end
        else begin
            case (state)

                IDLE: begin
                    if(out_en)
                        slave_clk <= 1'b1;
                    else
                        slave_clk <= 1'b0;
                end

                START_TX, DATA_TX: begin
                    slave_clk <= (count == 3'd3 || count == 3'd7)? ~slave_clk : slave_clk; 
                end
                
                END_TX: begin
                    if (count < 3'd3)
                        slave_clk <= 1'b1;
                    else
                        slave_clk <= 1'b0;
                end

                default:
                    slave_clk <= 1'b0;
            endcase
        end
    end

    assign sclk = slave_clk;

    // Counter logic
    always @(posedge clk or negedge rstn) begin

        if (!rstn) begin
            count <= 1'd0;
            data_cycle <= 2'd0;
        end

        else begin
            case (state)

                IDLE: begin
                    count <= 3'd0;
                end

                START_TX, END_TX: begin
                    data_cycle <= 2'd0;
                    if (count < 3'd7)
                        count <= count + 1'd1;
                    else
                        count <= 3'd0;
                end

                DATA_TX : begin
                    if (count == 3'd7) begin
                        count <= 3'd0;
                        data_cycle <= data_cycle + 1'd1;
                    end else begin
                        count <= count + 1'd1;
                    end
                end

                default: begin
                    count <= 3'd0;
                    data_cycle <= 2'd0;
                end

            endcase
        end
    end

    // state trans
    always @(*) begin

        case(state)

            IDLE: begin
                DL0 = 4'd0;
                DL1 = 4'd0;
                CS  = 1'd1;
                if (out_en)
                    next_state = START_TX;
                else
                    next_state = IDLE;
            end

            START_TX: begin
                DL0 = 4'd0;
                DL1 = 4'd0;
                CS  = 1'd0;
                if(count == 3'd7)
                    next_state = DATA_TX;
                else
                    next_state = START_TX;
            end

            DATA_TX: begin
                // Data is passed from LSB to MSB
                DL0 = data_in [3 - data_cycle];
                DL1 = data_in [7 - data_cycle];
                if(data_cycle == 2'd3 && count == 3'd7)
                    next_state = END_TX;
                else
                    next_state = DATA_TX;
            end

            END_TX: begin
                DL0 = 4'd0;
                DL1 = 4'd0;
                CS  = 1'd1;
                if(count == 3'd7)
                    next_state = IDLE;
                else
                    next_state = END_TX;
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule //master