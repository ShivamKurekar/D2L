// Code for Master Dual Data Link (D2L)

module master (
    input clk, rstn,
    input out_en,
    input [70:0] data,
    output sclk, // slave clock generated by master to communicate
    output DataLine0, DataLine1,
    output reg CS // CS == 0 selecting the slave device, CS == 1 by default
);

    reg DL0, DL1;
    reg [6:0]  d_width;
    reg [63:0] shreg;

    reg [3:0] state, next_state;
    reg [2:0] count;

    reg slave_clk = 1'b0;
    reg [5:0] data_cycle;

    localparam IDLE = 0;
    localparam START_TX = 1;
    localparam DATA_TX = 2;
    localparam END_TX = 3;

    always @(posedge clk or negedge rstn) begin
        if (!rstn)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Slave clock generator
    always @(posedge clk or negedge rstn) begin

        if(!rstn) begin
            slave_clk <= 1'b0;
        end
        else begin
            case (state)

                IDLE: begin
                    if(out_en)
                        slave_clk <= 1'b1;
                    else
                        slave_clk <= 1'b0;
                end

                START_TX, DATA_TX: begin
                    slave_clk <= (count == 3'd3 || count == 3'd7)? ~slave_clk : slave_clk; 
                end
                
                END_TX: begin
                    if (count < 3'd3)
                        slave_clk <= 1'b1;
                    else
                        slave_clk <= 1'b0;
                end

                default:
                    slave_clk <= 1'b0;
            endcase
        end
    end

    assign sclk = slave_clk;

    // Counter logic
    always @(posedge clk or negedge rstn) begin

        if (!rstn) begin
            count <= 1'd0;
            data_cycle <= 5'd0;
        end

        else begin
            case (state)

                IDLE: begin
                    count <= 3'd0;
                end

                START_TX: begin
                    data_cycle <= 5'd0;
                    if (count == 3'd0) begin
                        d_width <= data[70:64];
                        shreg   <= data[63:0];
                        count <= count + 1'd1;
                    end
                    else if (count < 3'd7)
                        count <= count + 1'd1;
                    else
                        count <= 3'd0;
                end


                DATA_TX : begin
                    if (count == 3'd7) begin
                        count <= 3'd0;
                        shreg <= shreg >> 2;
                        if (data_cycle < (d_width >> 1) - 1)
                            data_cycle <= data_cycle + 1'd1;
                    end else begin
                        count <= count + 1'd1;
                    end
                end

                END_TX: begin
                    data_cycle <= 5'd0;
                    d_width <= 0;
                    shreg <= 0;
                    if (count < 3'd7)
                        count <= count + 1'd1;
                    else
                        count <= 3'd0;
                end

                default: begin
                    count <= 3'd0;
                    data_cycle <= 5'd0;
                end

            endcase
        end
    end

    // state trans
    always @(*) begin
        
        next_state = state;
        DL0 = 1'b0;
        DL1 = 1'b0;
        CS  = 1'b1;

        case(state)

            IDLE: begin
                DL0 = 1'd0;
                DL1 = 1'd0;
                CS  = 1'd1;
                if (out_en)
                    next_state = START_TX;
                else
                    next_state = IDLE;
            end

            START_TX: begin
                DL0 = 1'd0;
                DL1 = 1'd0;
                CS  = 1'd0;
                if(count == 3'd7)
                    next_state = DATA_TX;
                else
                    next_state = START_TX;
            end

            DATA_TX: begin
                // Data is passed from LSB to MSB
                DL0 = shreg[0]; //Lower half bits
                DL1 = shreg[1]; //Upper half bits
                if(data_cycle == (d_width >> 1) - 1 && count == 3'd7)
                    next_state = END_TX;
                else
                    next_state = DATA_TX;
            end

            END_TX: begin
                DL0 = 1'd0;
                DL1 = 1'd0;
                CS  = 1'd1;
                if(count == 3'd7)
                    next_state = IDLE;
                else
                    next_state = END_TX;
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

    assign DataLine0 = DL0;
    assign DataLine1 = DL1;

endmodule //master