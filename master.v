// Code for Master Dual Data Link (D2L)

module master (
    input clk, rstn,
    input out_en,
    output sclk, // slave clock generated by master to communicate
    output reg [3:0] DL0, DL1,
    output reg CS
);

    
    reg [7:0]  data_in = 8'b1111_0101;

    reg [3:0] state, next_state;
    reg [2:0] count;

    reg slave_clk = 1'b0;
    reg [1:0] data_cycle;

    localparam IDLE = 0;
    localparam START_TX = 1;
    localparam DATA_TX = 2;
    localparam END_TX = 3;

    always @(posedge clk or negedge rstn) begin
        if (!rstn)
            state = IDLE;
        else
            state = next_state;
    end

    always @(posedge clk) begin
        case (state)

            IDLE: slave_clk <= 1'b0;

            START_TX, DATA_TX: begin
                if (count < 3'd3 || count == 3'd7)
                    slave_clk = 1'b1;
                else
                    slave_clk = 1'b0;
            end

            END_TX: slave_clk <= 1'b0;

            default:
                slave_clk <= 1'b0;

        endcase
    end

    assign sclk = slave_clk;

    // counter
    always @(posedge clk) begin
        case (state)

            IDLE: begin
                if (count < 3'd7)
                    count <= count + 1'd1;
                else
                    count <= 1'd0;
            end

            START_TX, END_TX: begin
                count <= count + 1'd1;
                data_cycle <= 2'd0;
            end

            DATA_TX : begin
                if (data_cycle != 2'd3)
                    if (count < 3'd7)
                        count <= count + 1'd1;
                    else begin
                        count <= 1'd0;
                        data_cycle <= data_cycle + 1'd1;
                    end
            end

            default: begin
                count <= 3'd0;
                data_cycle <= 2'd0;
            end

        endcase
    end

    // state trans
    always @(*) begin

        case(state)

            IDLE: begin
                DL0 = 4'd0;
                DL1 = 4'd0;
                CS  = 1'd1;
                if (out_en)
                    next_state = START_TX;
                else
                    next_state = IDLE;
            end

            START_TX: begin
                DL0 = 4'd0;
                DL1 = 4'd0;
                CS  = 1'd0;
                if(count == 3'd7)
                    next_state = DATA_TX;
                else
                    next_state = START_TX;
            end

            DATA_TX: begin
                DL0 = data_in [3 - data_cycle];
                DL1 = data_in [7 - data_cycle];
                if(count == 3'd7)
                    next_state = END_TX;
                else
                    next_state = DATA_TX;
            end

            END_TX: begin
                DL0 = 4'd0;
                DL1 = 4'd0;
                CS  = 1'd1;
                if(count == 3'd7)
                    next_state = IDLE;
                else
                    next_state = END_TX;
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule //master